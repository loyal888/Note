{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"45411","rootPoint":{"objectClass":"CGPoint","x":360,"y":7255.5},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"W3D4W","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"JWRR7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"UI8MY","lineColorHex":"#BF58F5","text":"用法"},"1":{"objectClass":"MindNode","ID":"K5B37","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2EK1H","lineColorHex":"#BF58F5","text":"了解 ContentProvider 的生命周期"},"1":{"objectClass":"MindNode","ID":"9P3R2","lineColorHex":"#BF58F5","text":"熟悉 ContentProvider 的启动流程"},"2":{"objectClass":"MindNode","ID":"49I22","lineColorHex":"#BF58F5","text":"熟悉 Provider 启动过程中各方通信原理"},"objectClass":"NSArray"},"text":"Provider 的启动原理"},"objectClass":"NSArray"},"text":"ContentProvider"},"1":{"objectClass":"MindNode","ID":"NYBO6","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"129HM","lineColorHex":"#BF58F5","text":"Thread、AsycTask、IntentService的使用场景与特点。"},"1":{"objectClass":"MindNode","ID":"LH3X1","lineColorHex":"#BF58F5","text":"进程保活"},"2":{"objectClass":"MindNode","ID":"0H849","lineColorHex":"#BF58F5","text":"什么是 UI 线程？"},"3":{"objectClass":"MindNode","ID":"8D28L","lineColorHex":"#BF58F5","text":"消息屏障"},"4":{"objectClass":"MindNode","ID":"3J17T","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1K45M","lineColorHex":"#BF58F5","text":"1. 可以在子线程创建 handler 嘛？"},"1":{"objectClass":"MindNode","ID":"J97FW","lineColorHex":"#BF58F5","text":"2. 主线程的 Looper 和子线程的 Looper 有什么区别？"},"2":{"objectClass":"MindNode","ID":"440Q2","lineColorHex":"#BF58F5","text":"3. Looper 的 MessageQueue 有什么关系？"},"3":{"objectClass":"MindNode","ID":"SGP5X","lineColorHex":"#BF58F5","text":"4. MessageQueue 是怎么创建的？"},"objectClass":"NSArray"},"text":"线程的消息队列是怎么创建的？"},"5":{"objectClass":"MindNode","ID":"92CRW","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"WQZT0","lineColorHex":"#BF58F5","text":"1. 消息循环过程是怎样的？"},"1":{"objectClass":"MindNode","ID":"00V4P","lineColorHex":"#BF58F5","text":"2. 消息是怎么发送的？"},"2":{"objectClass":"MindNode","ID":"DA717","lineColorHex":"#BF58F5","text":"3. 消息是怎么处理的？\n"},"objectClass":"NSArray"},"text":"线程间消息传递机制"},"6":{"objectClass":"MindNode","ID":"Y471M","lineColorHex":"#BF58F5","text":"HandlerThread"},"objectClass":"NSArray"},"text":"线程"},"2":{"objectClass":"MindNode","ID":"G0UG7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"0SE5A","lineColorHex":"#BF58F5","text":"10.布局之间的对比"},"1":{"objectClass":"MindNode","ID":"G80H8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2BL11","lineColorHex":"#BF58F5","text":"UI卡顿优化？"},"objectClass":"NSArray"},"text":"UI优化？"},"2":{"objectClass":"MindNode","ID":"H6664","lineColorHex":"#BF58F5","text":"14. Merge、ViewStub的作用。"},"3":{"objectClass":"MindNode","ID":"UCWEG","lineColorHex":"#BF58F5","text":"屏幕适配方式？"},"4":{"objectClass":"MindNode","ID":"85PJU","lineColorHex":"#BF58F5","text":"安卓支持的颜色模式？"},"5":{"objectClass":"MindNode","ID":"IN5X8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"3YXL2","lineColorHex":"#BF58F5","text":" Bitmap的高效加载？"},"objectClass":"NSArray"},"text":"23. Bitmap的四中属性，与每种属性队形的大小。"},"6":{"objectClass":"MindNode","ID":"25NDU","lineColorHex":"#BF58F5","text":"24. View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。"},"7":{"objectClass":"MindNode","ID":"75H5Y","lineColorHex":"#BF58F5","text":"RecyclerView比ListView做了哪些优化？"},"8":{"objectClass":"MindNode","ID":"3GQG3","lineColorHex":"#BF58F5","text":"自定义控件原理，及消息分发流程。"},"9":{"objectClass":"MindNode","ID":"DQKE0","lineColorHex":"#BF58F5","text":".measure layout draw流程，滑动冲突"},"10":{"objectClass":"MindNode","ID":"1R6Y5","lineColorHex":"#BF58F5","text":"Measure、Layout、draw大流程、绘制顺序"},"11":{"objectClass":"MindNode","ID":"JJK8Y","lineColorHex":"#BF58F5","text":"事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？"},"12":{"objectClass":"MindNode","ID":"39F33","lineColorHex":"#BF58F5","text":"ListView 中图片错位的问题是如何产生的；"},"13":{"objectClass":"MindNode","ID":"ZQ409","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"3732K","lineColorHex":"#BF58F5","text":"自定义View的事件"},"1":{"objectClass":"MindNode","ID":"3XB3R","lineColorHex":"#BF58F5","text":"自定义View如何提供获取View属性的接口；"},"objectClass":"NSArray"},"text":"自定义View如何考虑机型适配；"},"14":{"objectClass":"MindNode","ID":"5S571","lineColorHex":"#BF58F5","text":"屏幕适配的处理技巧都有哪些；"},"15":{"objectClass":"MindNode","ID":"66K36","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"81KI2","lineColorHex":"#BF58F5","text":"Surface 跨进程传递原理"},"1":{"objectClass":"MindNode","ID":"1S71Z","lineColorHex":"#BF58F5","text":"Surface 的绘制原理"},"objectClass":"NSArray"},"text":"Surface"},"16":{"objectClass":"MindNode","ID":"CKCGT","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"VL9I7","lineColorHex":"#BF58F5","text":"1. 丢帧一般是什么原因引起的？"},"1":{"objectClass":"MindNode","ID":"1RL15","lineColorHex":"#BF58F5","text":"2. Android 刷新频率 60 帧/秒，每隔 16 ms 调 onDraw 绘制一次？"},"2":{"objectClass":"MindNode","ID":"13CMX","lineColorHex":"#BF58F5","text":"3. onDraw 完之后屏幕会马上刷新吗？"},"3":{"objectClass":"MindNode","ID":"PQ180","lineColorHex":"#BF58F5","text":"4. 如果界面没有重绘，还会每隔 16ms 刷新屏幕吗？"},"4":{"objectClass":"MindNode","ID":"516AK","lineColorHex":"#BF58F5","text":"5. 如果在屏幕快要刷新的时候才去 onDraw 绘制会丢帧吗？"},"objectClass":"NSArray"},"text":"Android 的 UI 刷新机制"},"17":{"objectClass":"MindNode","ID":"3EC1O","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"L1QDK","lineColorHex":"#BF58F5","text":"1. Vsync 信号的生成机制"},"1":{"objectClass":"MindNode","ID":"88554","lineColorHex":"#BF58F5","text":"2. Vsync 在 SurfaceFlinger 中的分发流程"},"2":{"objectClass":"MindNode","ID":"8UMR1","lineColorHex":"#BF58F5","text":"3. Vsync 信号的分发原理"},"objectClass":"NSArray"},"text":"Vsync 信号机制"},"objectClass":"NSArray"},"text":"UI"},"3":{"objectClass":"MindNode","ID":"89AR3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"F5YFQ","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"45Q52","lineColorHex":"#BF58F5","text":"五大存储"},"objectClass":"NSArray"},"text":"11. Android的数据存储形式"},"1":{"objectClass":"MindNode","ID":"P21V4","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"755HV","lineColorHex":"#BF58F5","text":"B tree 和 B+tree?"},"objectClass":"NSArray"},"text":"数据库"},"objectClass":"NSArray"},"text":"存储"},"4":{"objectClass":"MindNode","ID":"2MJ9Z","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"4S69C","lineColorHex":"#BF58F5","text":"16. 动画有哪两类，各有什么特点？"},"1":{"objectClass":"MindNode","ID":"Q89YU","lineColorHex":"#BF58F5","text":"动画框架？"},"objectClass":"NSArray"},"text":"动画"},"5":{"objectClass":"MindNode","ID":"NX4MX","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"FN562","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"28427","lineColorHex":"#BF58F5","text":"是否熟悉Lopper架构，如果熟悉说下其原理，如果你自己实现，你会怎么实现。这里主要考察阻塞消息队列原理，和其变形"},"1":{"objectClass":"MindNode","ID":"P835V","lineColorHex":"#BF58F5","text":"handler的post(Runnable)如何实现的。callback，runnable，msg的执行优先级。"},"2":{"objectClass":"MindNode","ID":"33S47","lineColorHex":"#BF58F5","text":"阻塞是怎么实现的？为什么不会阻塞主线程？"},"3":{"objectClass":"MindNode","ID":"WNXLZ","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"WISU5","lineColorHex":"#BF58F5","text":"1. 了解 IdleHandler 的作用以及调用方式"},"1":{"objectClass":"MindNode","ID":"5DLQW","lineColorHex":"#BF58F5","text":"2. 了解 IdleHandler 有哪些使用场景"},"2":{"objectClass":"MindNode","ID":"D55LR","lineColorHex":"#BF58F5","text":"3. 熟悉 IdleHandler 的实现原理"},"objectClass":"NSArray"},"text":"IdleHandler 原理"},"objectClass":"NSArray"},"text":"17. Handler、Loop消息队列模型，各部分的作用。"},"1":{"objectClass":"MindNode","ID":"7FMVN","lineColorHex":"#BF58F5","text":"22. Android中弱引用与软引用的应用场景。"},"2":{"objectClass":"MindNode","ID":"IN57K","lineColorHex":"#BF58F5","text":"25. Touch事件分发机制。"},"3":{"objectClass":"MindNode","ID":"C1KJ2","lineColorHex":"#BF58F5","text":"26. Android长连接，怎么处理心跳机制。"},"4":{"objectClass":"MindNode","ID":"9888N","lineColorHex":"#BF58F5","text":"27. Zygote的启动过程。"},"5":{"objectClass":"MindNode","ID":"UC3Y5","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7GXRM","lineColorHex":"#BF58F5","text":"Activity 的启动流程"},"objectClass":"NSArray"},"text":"28. Android IPC:Binder原理。"},"6":{"objectClass":"MindNode","ID":"350NR","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"HLVG5","lineColorHex":"#BF58F5","text":"类加载机制问的也不少，除了 Java 中的，还可以说一下 Android 中的 DexClassLoader，Android 8 的改动？然后就可以引申到了插件化和热修复了。"},"objectClass":"NSArray"},"text":"Activity, View, Window三者关系？"},"7":{"objectClass":"MindNode","ID":"99B4E","lineColorHex":"#BF58F5","text":"ANR(应用程序没有响应)(Application not response)？"},"8":{"objectClass":"MindNode","ID":"R6G43","lineColorHex":"#BF58F5","text":"Android的事件分发机制"},"9":{"objectClass":"MindNode","ID":"56L95","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7W246","lineColorHex":"#BF58F5","text":"实现原理？"},"objectClass":"NSArray"},"text":"SharedPreference"},"10":{"objectClass":"MindNode","ID":"Y7X5D","lineColorHex":"#BF58F5","text":"compileSdkVersion、minSdkVersion、targetSdkVersion 的区别和作用？"},"11":{"objectClass":"MindNode","ID":"8V9TL","lineColorHex":"#BF58F5","text":"是否了解ActivityManagerService，它发挥什么作用，说一下AMS启动流程？"},"12":{"objectClass":"MindNode","ID":"E772H","lineColorHex":"#BF58F5","text":"Context是什么？"},"13":{"objectClass":"MindNode","ID":"438MT","lineColorHex":"#BF58F5","text":"ActivityThread，Ams，Wms的工作原理。"},"14":{"objectClass":"MindNode","ID":"MKMN2","lineColorHex":"#BF58F5","text":"如果工作中需要修改framework，你如何寻找切入点。"},"15":{"objectClass":"MindNode","ID":"4N9OI","lineColorHex":"#BF58F5","text":"用MultiDex解决何事？其根本原因在于？Dex如何优化？主Dex放哪些东西？主Dex和其他\nDex调用、关联？Odex优化点在于什么？"},"16":{"objectClass":"MindNode","ID":"3F05V","lineColorHex":"#BF58F5","text":"Dalvik和Art虚拟机区别？"},"17":{"objectClass":"MindNode","ID":"QKC22","lineColorHex":"#BF58F5","text":"多渠道打包如何实现(Flavor、Dimension应用)？从母包生出渠道包实现方法？渠道标识替换原理？"},"18":{"objectClass":"MindNode","ID":"0O701","lineColorHex":"#BF58F5","text":"Android打包哪些类型文件不能混淆？"},"19":{"objectClass":"MindNode","ID":"3SVCD","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5617W","lineColorHex":"#BF58F5","text":"主线程为什么没有 ANR？"},"objectClass":"NSArray"},"text":"什么是ANR 如何避免它？"},"20":{"objectClass":"MindNode","ID":"W1812","lineColorHex":"#BF58F5","text":"ApplicationContext和ActivityContext的区别；"},"21":{"objectClass":"MindNode","ID":"524O7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"744IH","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"E7471","lineColorHex":"#BF58F5","text":"Linux 内核层"},"1":{"objectClass":"MindNode","ID":"BI2P3","lineColorHex":"#BF58F5","text":"硬件抽象层 HAL"},"2":{"objectClass":"MindNode","ID":"R3X0F","lineColorHex":"#BF58F5","text":"Native C/C++ 库 && Android Runtime"},"3":{"objectClass":"MindNode","ID":"XQ231","lineColorHex":"#BF58F5","text":"Java Framework 层"},"4":{"objectClass":"MindNode","ID":"PS2EU","lineColorHex":"#BF58F5","text":"System Apps 层"},"objectClass":"NSArray"},"text":"五层架构"},"objectClass":"NSArray"},"text":"Android 系统架构"},"22":{"objectClass":"MindNode","ID":"63347","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"FFSGE","lineColorHex":"#BF58F5","text":"构建流程"},"objectClass":"NSArray"},"text":"Android APK 构建流程"},"23":{"objectClass":"MindNode","ID":"1IJ03","lineColorHex":"#BF58F5","text":"智能指针"},"objectClass":"NSArray"},"text":"系统"},"6":{"objectClass":"MindNode","ID":"7WT6F","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"C1IJC","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"91HF8","lineColorHex":"#BF58F5","text":"注解的信息存放在哪？注解的两种处理方式（反射和 APT ）"},"objectClass":"NSArray"},"text":"运行时注解、编译时注解"},"objectClass":"NSArray"},"text":"Java注解"},"7":{"objectClass":"MindNode","ID":"I3H10","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"RNNJU","lineColorHex":"#BF58F5","text":"1. Activity与Fragment的生命周期？"},"1":{"objectClass":"MindNode","ID":"25T66","lineColorHex":"#BF58F5","text":"2. Acitivty的四中启动模式与特点？"},"2":{"objectClass":"MindNode","ID":"HDU6J","lineColorHex":"#BF58F5","text":"3. Activity缓存方法。"},"3":{"objectClass":"MindNode","ID":"J1XYJ","lineColorHex":"#BF58F5","text":"20. Android怎么加速启动Activity。"},"4":{"objectClass":"MindNode","ID":"QVMJF","lineColorHex":"#BF58F5","text":"Activity与Fragment通信方式？"},"5":{"objectClass":"MindNode","ID":"6QV5D","lineColorHex":"#BF58F5","text":"说下Activity的生命周期？"},"6":{"objectClass":"MindNode","ID":"K14C1","lineColorHex":"#BF58F5","text":"后台的Activity被系统回收怎么办？"},"7":{"objectClass":"MindNode","ID":"S4BK9","lineColorHex":"#BF58F5","text":" 如何避免配置改变时Activity重建？"},"8":{"objectClass":"MindNode","ID":"X1Q42","lineColorHex":"#BF58F5","text":"app切换到后台，当前activity会走onDestory方法吗？"},"9":{"objectClass":"MindNode","ID":"P1444","lineColorHex":"#BF58F5","text":" Activity的启动过程是怎样的，有几种方式？"},"10":{"objectClass":"MindNode","ID":"OUDD7","lineColorHex":"#BF58F5","text":"两个Activity之间怎么传递数据？"},"11":{"objectClass":"MindNode","ID":"31WUK","lineColorHex":"#BF58F5","text":"知道哪些Activity启动模式的标记位？flag是干什么用的，什么时候用到？"},"12":{"objectClass":"MindNode","ID":"N32F0","lineColorHex":"#BF58F5","text":"同一程序不同的Activity是否可以放在不同的Task任务栈中？"},"13":{"objectClass":"MindNode","ID":"GYKY8","lineColorHex":"#BF58F5","text":"Activity创建Fragment的方式是什么？"},"14":{"objectClass":"MindNode","ID":"R1J3X","lineColorHex":"#BF58F5","text":" getActivity()空指针"},"15":{"objectClass":"MindNode","ID":"0K43B","lineColorHex":"#BF58F5","text":"一个activity启动另外一个activity的生命周期"},"16":{"objectClass":"MindNode","ID":"SY77N","lineColorHex":"#BF58F5","text":"插件化。启动activity的hook方式。taskAffity。"},"17":{"objectClass":"MindNode","ID":"W11O6","lineColorHex":"#BF58F5","text":"Application和Activity在Context的继承树上有何区别？二者使用上有何不同？"},"18":{"objectClass":"MindNode","ID":"TK661","lineColorHex":"#BF58F5","text":"Activity状态保存于恢复；"},"19":{"objectClass":"MindNode","ID":"Y4577","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"JI5NB","lineColorHex":"#BF58F5","text":"Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用应该如何解耦；"},"objectClass":"NSArray"},"text":"Fragment"},"20":{"objectClass":"MindNode","ID":"387M4","lineColorHex":"#BF58F5","text":"Activity 的显示原理"},"objectClass":"NSArray"},"text":"Activity"},"8":{"objectClass":"MindNode","ID":"R8S78","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"GJ7BG","lineColorHex":"#BF58F5","text":"4. Service的生命周期，两种启动方法，有什么区别。"},"1":{"objectClass":"MindNode","ID":"2Y52Y","lineColorHex":"#BF58F5","text":"5. 怎么保证service不被杀死。"},"2":{"objectClass":"MindNode","ID":"LLRP4","lineColorHex":"#BF58F5","text":"Service和Thread的区别"},"3":{"objectClass":"MindNode","ID":"58963","lineColorHex":"#BF58F5","text":"是否能在Service进行耗时操作？"},"4":{"objectClass":"MindNode","ID":"54XSJ","lineColorHex":"#BF58F5","text":"Activity如何与Service通信？"},"5":{"objectClass":"MindNode","ID":"ZQ9N7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"S725I","lineColorHex":"#BF58F5","text":"1. Service 启动有哪几种方式？"},"1":{"objectClass":"MindNode","ID":"YR7F5","lineColorHex":"#BF58F5","text":"2. Service 启动过程中主要流程有哪些？"},"2":{"objectClass":"MindNode","ID":"J4976","lineColorHex":"#BF58F5","text":"3. Service 启动过程涉及哪些参与者，通信过程是怎样的？"},"objectClass":"NSArray"},"text":"Service 的启动原理"},"6":{"objectClass":"MindNode","ID":"M1I4Q","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"4666A","lineColorHex":"#BF58F5","text":"1. 知道 bindService 的用法"},"1":{"objectClass":"MindNode","ID":"79VIB","lineColorHex":"#BF58F5","text":"2. 了解 bindService 的大致流程"},"2":{"objectClass":"MindNode","ID":"4OEJ6","lineColorHex":"#BF58F5","text":"3. bindService 涉及哪些参与者，通信过程是怎样的？"},"objectClass":"NSArray"},"text":"Service 的绑定原理"},"objectClass":"NSArray"},"text":"Service"},"9":{"objectClass":"MindNode","ID":"23R5J","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"436D4","lineColorHex":"#BF58F5","text":"6. 广播的两种注册方法，有什么区别。"},"1":{"objectClass":"MindNode","ID":"25HKD","lineColorHex":"#BF58F5","text":"如何通过广播拦截和abort一条短信？"},"2":{"objectClass":"MindNode","ID":"8B365","lineColorHex":"#BF58F5","text":"广播是否可以请求网络？"},"3":{"objectClass":"MindNode","ID":"XGFC2","lineColorHex":"#BF58F5","text":"广播引起anr的时间限制？"},"4":{"objectClass":"MindNode","ID":"285DT","lineColorHex":"#BF58F5","text":"在manifest 和代码中如何注册和使用BroadcastReceiver；"},"5":{"objectClass":"MindNode","ID":"RR886","lineColorHex":"#BF58F5","text":"请描述一下BroadcastReceiver；"},"6":{"objectClass":"MindNode","ID":"XDJ7Q","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7HQ0P","lineColorHex":"#BF58F5","text":"1. 动态广播的注册原理"},"1":{"objectClass":"MindNode","ID":"59VM2","lineColorHex":"#BF58F5","text":"2. 广播的发送原理"},"2":{"objectClass":"MindNode","ID":"ZY0SC","lineColorHex":"#BF58F5","text":"3. 广播的接收原理"},"objectClass":"NSArray"},"text":"动态广播的注册和收发原理"},"7":{"objectClass":"MindNode","ID":"GDJBO","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"3KT6P","lineColorHex":"#BF58F5","text":"1. 静态广播是怎么注册的"},"1":{"objectClass":"MindNode","ID":"W1A4W","lineColorHex":"#BF58F5","text":"2. 静态广播是串行分发的"},"2":{"objectClass":"MindNode","ID":"W283T","lineColorHex":"#BF58F5","text":"3. 静态广播的生命周期及上下文"},"objectClass":"NSArray"},"text":"静态广播的注册和收发原理"},"objectClass":"NSArray"},"text":"Broadcast\n"},"10":{"objectClass":"MindNode","ID":"UHN65","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"FN75X","lineColorHex":"#BF58F5","text":"7. Intent的使用方法，可以传递哪些数据类型。"},"1":{"objectClass":"MindNode","ID":"TRP6E","lineColorHex":"#BF58F5","text":"Serializable和Parcelable的区别？"},"2":{"objectClass":"MindNode","ID":"33PSF","lineColorHex":"#BF58F5","text":"什么是AIDL 以及如何使用；"},"3":{"objectClass":"MindNode","ID":"D48XB","lineColorHex":"#BF58F5","text":"观察者模式、EventBus、广播BroadcastReciver的区别"},"4":{"objectClass":"MindNode","ID":"O6LAS","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"15W77","lineColorHex":"#BF58F5","text":"1. 了解各种跨进程传输数据的方式及各自优缺点"},"1":{"objectClass":"MindNode","ID":"4L654","lineColorHex":"#BF58F5","text":"2. 了解 TransactionTooLargeException 的触发原因和底层机制"},"2":{"objectClass":"MindNode","ID":"66O07","lineColorHex":"#BF58F5","text":"了解 Bitmap 传输底层原理"},"objectClass":"NSArray"},"text":"跨进程传递大图片"},"objectClass":"NSArray"},"text":"数据传递"},"11":{"objectClass":"MindNode","ID":"N2551","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"LOR5U","lineColorHex":"#BF58F5","text":"13. Android中的MVC、MVP、MVVM模式。"},"1":{"objectClass":"MindNode","ID":"75679","lineColorHex":"#BF58F5","text":"AOP原理"},"objectClass":"NSArray"},"text":"设计模式"},"12":{"objectClass":"MindNode","ID":"698B3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"24JB6","lineColorHex":"#BF58F5","text":"21. Android内存优化方法：ListView优化，及时关闭资源，图片缓存等等。"},"1":{"objectClass":"MindNode","ID":"6L2C1","lineColorHex":"#BF58F5","text":"如何减少apk安装包体积"},"2":{"objectClass":"MindNode","ID":"RRD5J","lineColorHex":"#BF58F5","text":"自定义控件优化方案？"},"3":{"objectClass":"MindNode","ID":"7Y883","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"ZVU4A","lineColorHex":"#BF58F5","text":"OOM的避免异常及解决方法；"},"objectClass":"NSArray"},"text":"Android 性能优化最佳实践","remark":"https://juejin.im/post/6844903641032163336"},"4":{"objectClass":"MindNode","ID":"XN111","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"VO25U","lineColorHex":"#BF58F5","text":"速度","remark":"1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间"},"1":{"objectClass":"MindNode","ID":"L5H52","lineColorHex":"#BF58F5","text":"成功率","remark":"1.失败重试策略；"},"2":{"objectClass":"MindNode","ID":"784YP","lineColorHex":"#BF58F5","text":"流量","remark":"1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存"},"3":{"objectClass":"MindNode","ID":"A4264","lineColorHex":"#BF58F5","text":"协议层的优化","remark":"比如更优的 http 版本等"},"objectClass":"NSArray"},"text":"网络优化及检测"},"5":{"objectClass":"MindNode","ID":"LS61W","lineColorHex":"#BF58F5","text":" I/O 优化"},"6":{"objectClass":"MindNode","ID":"8V45Q","lineColorHex":"#BF58F5","text":"UI 优化"},"7":{"objectClass":"MindNode","ID":"8S2FD","lineColorHex":"#BF58F5","text":"内存优化"},"8":{"objectClass":"MindNode","ID":"DO766","lineColorHex":"#BF58F5","text":"包体积优化"},"9":{"objectClass":"MindNode","ID":"84733","lineColorHex":"#BF58F5","text":"卡顿优化"},"10":{"objectClass":"MindNode","ID":"DWXI5","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"98Y13","lineColorHex":"#BF58F5","text":"冷启动"},"1":{"objectClass":"MindNode","ID":"MF29S","lineColorHex":"#BF58F5","text":"热启动"},"objectClass":"NSArray"},"text":"启动优化"},"11":{"objectClass":"MindNode","ID":"UE2XI","lineColorHex":"#BF58F5","text":"存储优化"},"12":{"objectClass":"MindNode","ID":"APR0H","lineColorHex":"#BF58F5","text":"崩溃优化"},"13":{"objectClass":"MindNode","ID":"582TY","lineColorHex":"#BF58F5","text":"电量优化"},"objectClass":"NSArray"},"text":"优化"},"13":{"objectClass":"MindNode","ID":"A0ICO","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"V8DD7","lineColorHex":"#BF58F5","text":"导致内存泄漏的场景？"},"1":{"objectClass":"MindNode","ID":"5N417","lineColorHex":"#BF58F5","text":"OOM(内存溢出)(Out of memory)？"},"2":{"objectClass":"MindNode","ID":"3Z2YP","lineColorHex":"#BF58F5","text":"一条最长的短信息约占多少byte?"},"3":{"objectClass":"MindNode","ID":"I3R5K","lineColorHex":"#BF58F5","text":"一些常见的 Linux 命令了解吗？"},"4":{"objectClass":"MindNode","ID":"8UXPU","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5UKSK","lineColorHex":"#BF58F5","text":" Android Framework 层使用到的智能指针，它就是使用的引用计数，然后说一下它是怎么解决循环引用问题的"},"objectClass":"NSArray"},"text":"内存对象的循环引用及避免；"},"5":{"objectClass":"MindNode","ID":"6LN4L","lineColorHex":"#BF58F5","text":"一张Bitmap所占内存以及内存占用的计算；"},"6":{"objectClass":"MindNode","ID":"SR566","lineColorHex":"#BF58F5","text":"Android Log类基本用法"},"7":{"objectClass":"MindNode","ID":"RW12S","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"ZN70C","lineColorHex":"#BF58F5","text":"ArrayMap"},"objectClass":"NSArray"},"text":"SparseArray介绍"},"objectClass":"NSArray"},"text":"常见问题"},"14":{"objectClass":"MindNode","ID":"SU4D1","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6BY27","lineColorHex":"#BF58F5","text":"你是如何理解Android操作系统的。"},"1":{"objectClass":"MindNode","ID":"5UQJS","lineColorHex":"#BF58F5","text":"是否熟悉framework层，如果熟悉，那就对framework做个简介。"},"2":{"objectClass":"MindNode","ID":"2CK4D","lineColorHex":"#BF58F5","text":"MVC概念（为什么有DAO层，什么作用）"},"3":{"objectClass":"MindNode","ID":"M6V82","lineColorHex":"#BF58F5","text":"说说mvc模式的原理，它在android中的运用"},"4":{"objectClass":"MindNode","ID":"RI41O","lineColorHex":"#BF58F5","text":"动态代理传入的参数都有哪些？非接口的类能实现动态代理吗？ASM的原理"},"5":{"objectClass":"MindNode","ID":"7036J","lineColorHex":"#BF58F5","text":"设计一个日志系统。"},"6":{"objectClass":"MindNode","ID":"788TU","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7378I","lineColorHex":"#BF58F5","text":"什么情况下会导致内存泄露；"},"objectClass":"NSArray"},"text":"内存泄露的分类。怎么查看内存泄露的问题"},"7":{"objectClass":"MindNode","ID":"4B33G","lineColorHex":"#BF58F5","text":"touch事件源码问题。"},"8":{"objectClass":"MindNode","ID":"B8M1H","lineColorHex":"#BF58F5","text":"组件化的问题。module和app之间的区别。moduler通信是如何实现的。"},"9":{"objectClass":"MindNode","ID":"ENO1U","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"11LBQ","lineColorHex":"#BF58F5","text":"请介绍一下NDK；"},"1":{"objectClass":"MindNode","ID":"7G266","lineColorHex":"#BF58F5","text":"什么是NDK库，如何在jni中注册native函数，有几种注册方式；"},"objectClass":"NSArray"},"text":"native奔溃的日志采集，怎么处理？"},"10":{"objectClass":"MindNode","ID":"3W8N2","lineColorHex":"#BF58F5","text":"注解实现一个提示功能：如果int的值大于了3需要提示。"},"11":{"objectClass":"MindNode","ID":"388YV","lineColorHex":"#BF58F5","text":"组件化、插件化介绍一下"},"12":{"objectClass":"MindNode","ID":"I69YW","lineColorHex":"#BF58F5","text":"webview中与js通信的手段有哪些？"},"13":{"objectClass":"MindNode","ID":"VU544","lineColorHex":"#BF58F5","text":"适配器和装饰模式各自特点和使用场景"},"14":{"objectClass":"MindNode","ID":"7405F","lineColorHex":"#BF58F5","text":"动态代理静态代理区别？"},"15":{"objectClass":"MindNode","ID":"7NCL6","lineColorHex":"#BF58F5","text":"模块化怎么做？怎么设计？接口发现暴漏怎么做？基于什么基本思想？"},"16":{"objectClass":"MindNode","ID":"440X6","lineColorHex":"#BF58F5","text":"MVC、MVP、MVVM应用和彼此本质区别？"},"17":{"objectClass":"MindNode","ID":"7B2I5","lineColorHex":"#BF58F5","text":"AsyncTask原理及不足；"},"18":{"objectClass":"MindNode","ID":"O8U76","lineColorHex":"#BF58F5","text":"IntentService原理；"},"19":{"objectClass":"MindNode","ID":"433KT","lineColorHex":"#BF58F5","text":"如何保证一个后台服务不被杀死；比较省电的方式是什么；"},"20":{"objectClass":"MindNode","ID":"1Q0C8","lineColorHex":"#BF58F5","text":"混合开发，RN，weex，H5，小程序"},"21":{"objectClass":"MindNode","ID":"LTIE1","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"B1L82","lineColorHex":"#BF58F5","text":"Dalvik 和 ART"},"1":{"objectClass":"MindNode","ID":"3ZKD8","lineColorHex":"#BF58F5","text":"APK 打包流程"},"2":{"objectClass":"MindNode","ID":"KN231","lineColorHex":"#BF58F5","text":"App 安装过程"},"3":{"objectClass":"MindNode","ID":"WL2H0","lineColorHex":"#BF58F5","text":"组件化路由实现"},"objectClass":"NSArray"},"text":"Android 模块化&热修复&热更新&打包&混淆&压缩"},"22":{"objectClass":"MindNode","ID":"4LDR2","lineColorHex":"#BF58F5","text":"Android 签名校验机制 v1、v2、v3"},"objectClass":"NSArray"},"text":"个人理解"},"15":{"objectClass":"MindNode","ID":"8745G","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5HH6E","lineColorHex":"#BF58F5","text":"多进程通信问题。binder优势。aidl生成的java类细节。多进程遇到哪些问题？"},"1":{"objectClass":"MindNode","ID":"3F582","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"W5342","lineColorHex":"#BF58F5","text":"什么时候支持 binder 机制的？"},"1":{"objectClass":"MindNode","ID":"DVROL","lineColorHex":"#BF58F5","text":"binder 启动时机"},"2":{"objectClass":"MindNode","ID":"N040O","lineColorHex":"#BF58F5","text":"怎么启用 Binder 机制？"},"objectClass":"NSArray"},"text":"应用是怎么启用 binder 机制的？"},"objectClass":"NSArray"},"text":"进程间通信"},"16":{"objectClass":"MindNode","ID":"G7PCW","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"G8MB5","lineColorHex":"#BF58F5","text":"ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)；"},"1":{"objectClass":"MindNode","ID":"923F1","lineColorHex":"#BF58F5","text":"说说ContentProvider、ContentResolver、ContentObserver 之间的关系；"},"2":{"objectClass":"MindNode","ID":"7YED3","lineColorHex":"#BF58F5","text":"请介绍下ContentProvider 是如何实现数据共享的；"},"objectClass":"NSArray"},"text":"ContantProvider"},"17":{"objectClass":"MindNode","ID":"5823X","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6UZND","lineColorHex":"#BF58F5","text":"谈谈你对 Application 的理解"},"1":{"objectClass":"MindNode","ID":"74HT3","lineColorHex":"#BF58F5","text":"Application 有什么用？"},"2":{"objectClass":"MindNode","ID":"0G5EF","lineColorHex":"#BF58F5","text":"Application 怎么初始化？"},"objectClass":"NSArray"},"text":"Application"},"18":{"objectClass":"MindNode","ID":"18R4K","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"O21M0","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"26EVA","lineColorHex":"#BF58F5","text":"Android 有哪些主要的系统进程？"},"1":{"objectClass":"MindNode","ID":"1Y5S5","lineColorHex":"#BF58F5","text":"这些系统进程是怎么启动的？以及做了什么事？"},"2":{"objectClass":"MindNode","ID":"J94XW","lineColorHex":"#BF58F5","text":"1. 系统服务是怎么启动的？"},"3":{"objectClass":"MindNode","ID":"0L3Y8","lineColorHex":"#BF58F5","text":"怎么解决系统服务之间的相互依赖？"},"4":{"objectClass":"MindNode","ID":"34H8I","lineColorHex":"#BF58F5","text":"系统服务跑在什么线程？"},"5":{"objectClass":"MindNode","ID":"85B7R","lineColorHex":"#BF58F5","text":"为什么系统服务不都跑在 binder 线程里呢？"},"6":{"objectClass":"MindNode","ID":"Y96S4","lineColorHex":"#BF58F5","text":"为什么系统服务不都跑在自己私有的工作线程里呢？"},"7":{"objectClass":"MindNode","ID":"LOQ4O","lineColorHex":"#BF58F5","text":"跑在 binder 线程和跑在工作线程，如何取舍？"},"objectClass":"NSArray"},"text":"Android 系统的启动流程"},"1":{"objectClass":"MindNode","ID":"BW09Z","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"64AN9","lineColorHex":"#BF58F5","text":"1. ServiceManager 启动流程是怎样的？"},"1":{"objectClass":"MindNode","ID":"37HDJ","lineColorHex":"#BF58F5","text":"2. 怎么获取 ServiceManager 的 binder 对象？"},"2":{"objectClass":"MindNode","ID":"EII97","lineColorHex":"#BF58F5","text":"3. 怎么向 ServiceManager 添加服务？"},"3":{"objectClass":"MindNode","ID":"RC872","lineColorHex":"#BF58F5","text":"4. 怎么从 ServiceManager 获取服务？"},"objectClass":"NSArray"},"text":"ServiceManager 的启动和工作原理"},"2":{"objectClass":"MindNode","ID":"86H8P","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"Y3S2M","lineColorHex":"#BF58F5","text":"了解 Zygote 的作用"},"objectClass":"NSArray"},"text":"谈谈你对 Zygote 的理解？"},"3":{"objectClass":"MindNode","ID":"TF33R","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"SLQ36","lineColorHex":"#BF58F5","text":"1. 启动方式有什么区别？"},"1":{"objectClass":"MindNode","ID":"EGAPK","lineColorHex":"#BF58F5","text":"2. 注册方式有什么区别？"},"2":{"objectClass":"MindNode","ID":"MI66K","lineColorHex":"#BF58F5","text":"3. 使用方式有什么区别？"},"objectClass":"NSArray"},"text":"系统服务和 bind 的应用服务有什么区别？"},"objectClass":"NSArray"},"text":"系统服务"},"19":{"objectClass":"MindNode","ID":"7IGBD","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"3B21K","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"T6TQK","lineColorHex":"#BF58F5","text":"1. binder 传递有哪些方式？"},"1":{"objectClass":"MindNode","ID":"8LD32","lineColorHex":"#BF58F5","text":"2. binder 在传递过程中是怎么存储的？"},"2":{"objectClass":"MindNode","ID":"SG2PN","lineColorHex":"#BF58F5","text":"3. binder 对象序列化和反序列化过程？"},"3":{"objectClass":"MindNode","ID":"C1675","lineColorHex":"#BF58F5","text":"4. binder 对象传递过程中驱动层做了什么？"},"objectClass":"NSArray"},"text":"Binder 对象跨进程传递的原理是怎样的？"},"1":{"objectClass":"MindNode","ID":"35VCT","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"K6A8B","lineColorHex":"#BF58F5","text":"1. binder 是干嘛的？"},"1":{"objectClass":"MindNode","ID":"M867G","lineColorHex":"#BF58F5","text":"2. binder 存在的意义是什么？"},"2":{"objectClass":"MindNode","ID":"KXW40","lineColorHex":"#BF58F5","text":"3. binder 的架构原理是怎样的？"},"objectClass":"NSArray"},"text":"谈谈你对 Binder 的理解？"},"2":{"objectClass":"MindNode","ID":"W3XZI","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"C81XY","lineColorHex":"#BF58F5","text":"1. 是否了解 Linux 常用的跨进程通信方式"},"1":{"objectClass":"MindNode","ID":"87475","lineColorHex":"#BF58F5","text":"2. 是否研究过 Android Framework 并了解一些实现原理"},"2":{"objectClass":"MindNode","ID":"U3IPK","lineColorHex":"#BF58F5","text":"3. 是否了解 Framework 各组件之间的通信原理"},"objectClass":"NSArray"},"text":"Android Framework 里面用到了哪些 IPC 方式？"},"3":{"objectClass":"MindNode","ID":"183W1","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"05P9U","lineColorHex":"#BF58F5","text":"1. 了解 binder 的整体架构原理"},"1":{"objectClass":"MindNode","ID":"O4L62","lineColorHex":"#BF58F5","text":"2. 了解应用和 binder 驱动的交互方式"},"2":{"objectClass":"MindNode","ID":"GUC18","lineColorHex":"#BF58F5","text":"3. 了解 IPC 过程中的通信协议"},"objectClass":"NSArray"},"text":"一次完整的 IPC 通信流程"},"4":{"objectClass":"MindNode","ID":"84DH3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"A1LBQ","lineColorHex":"#BF58F5","text":"1. binder 的 oneway 是什么意思？"},"1":{"objectClass":"MindNode","ID":"75K7U","lineColorHex":"#BF58F5","text":"2. oneway 有哪些特性？"},"2":{"objectClass":"MindNode","ID":"TDS57","lineColorHex":"#BF58F5","text":"3. 它的实现原理是怎样的？"},"objectClass":"NSArray"},"text":"说一说 binder 的 oneway 机制"},"objectClass":"NSArray"},"text":"进程间通信"},"20":{"objectClass":"MindNode","ID":"H44G7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"830KT","lineColorHex":"#BF58F5","text":"启动未在 Manifest 中注册的 Activity"},"1":{"objectClass":"MindNode","ID":"U41DP","lineColorHex":"#BF58F5","text":"热修复"},"objectClass":"NSArray"},"text":"插件化"},"21":{"objectClass":"MindNode","ID":"7K5T4","lineColorHex":"#BF58F5","text":"Gradle"},"objectClass":"NSArray"},"text":"Android"},"objectClass":"NSArray"},"text":""},"ID":"183W6"}