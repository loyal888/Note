{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"3M4C2","rootPoint":{"objectClass":"CGPoint","x":360,"y":689},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"LOAQ5","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"40WR8","lineColorHex":"#DC306C","text":"程序计数器"},"1":{"objectClass":"MindNode","ID":"QC97H","lineColorHex":"#DC306C","text":"虚拟机栈"},"2":{"objectClass":"MindNode","ID":"O62J0","lineColorHex":"#DC306C","text":"本地方法栈","summarizedNodeID":"40WR8","summarizedText":"随线程生，随线程死；基本不需要考虑，方法或线程结束时，内存即被回收"},"3":{"objectClass":"MindNode","ID":"7HD98","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"HC58X","lineColorHex":"#DC306C","text":"堆内存怎么回收？","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"Java堆","remark":"接口可能有多个实现，内存大小不固定，需要在运行时才能确定对象的大小，动态分配和动态回收"},"4":{"objectClass":"MindNode","ID":"56N42","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"MF68P","lineColorHex":"#DC306C","text":"废弃常量","remark":"没有人引用它"},"1":{"objectClass":"MindNode","ID":"91859","lineColorHex":"#DC306C","text":"无用的类"},"objectClass":"NSArray"},"text":"方法区"},"objectClass":"NSArray"},"text":"哪些内存需要回收？"},"1":{"objectClass":"MindNode","ID":"W4908","lineColorHex":"#BF58F5","text":"什么时候回收？"},"2":{"objectClass":"MindNode","ID":"I1N42","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Y1Y74","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"16C13","lineColorHex":"#26BBFF","text":"循环引用问题"},"objectClass":"NSArray"},"text":"引用计数法"},"1":{"objectClass":"MindNode","ID":"H69EC","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"XNYG2","lineColorHex":"#26BBFF","text":"GC-ROOT","remark":"O 虚拟机栈(栈帧中的本地变量表)中引用的对象。\nO 方法区中类静态属性引用的对象。\nO 方法区中常量引用的对象。\nO 本地方法栈中JNI (即一般说的Native方法)引用的对象。"},"objectClass":"NSArray"},"text":"可达性分析","remark":"可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链( Reference Chain)，当- 一个对象到GC Roots 没有任何引用链相连(用图论的话来说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。"},"2":{"objectClass":"MindNode","ID":"6YO65","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"9FBFV","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"11ER6","lineColorHex":"#26BBFF","text":"强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的\n引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。"},"objectClass":"NSArray"},"text":"强"},"1":{"objectClass":"MindNode","ID":"7WUFJ","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"DZB6W","lineColorHex":"#26BBFF","text":"软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统\n将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二二次回收。如\n果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供SoftReference类来实现软引用。"},"objectClass":"NSArray"},"text":"软"},"2":{"objectClass":"MindNode","ID":"6N046","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"2QZ54","lineColorHex":"#26BBFF","text":"弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱- -些，被弱引用\n关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当\n前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了\nWeakReference类来实现弱引用。"},"objectClass":"NSArray"},"text":"弱"},"3":{"objectClass":"MindNode","ID":"XM223","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"VRD39","lineColorHex":"#26BBFF","text":"虚引用也称为幽灵引用或者幻影引用，它是最弱的- -种引用关系。-一个对象是否有虚\n引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一 个对象实\n例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一\n个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。"},"objectClass":"NSArray"},"text":"虚"},"objectClass":"NSArray"},"text":"四种引用"},"objectClass":"NSArray"},"text":"如何回收？"},"objectClass":"NSArray"},"text":"垃圾回收","remark":"为什么要关注垃圾回收？\n\n当排查内存溢出、内存泄漏的时候，对自动化的垃圾回收进行必要监控。"},"ID":"GWQFQ"}