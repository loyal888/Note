{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"45U4A","rootPoint":{"objectClass":"CGPoint","x":360,"y":1346},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"VN9LW","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"QUN73","lineColorHex":"#B3EE3A","children":{"0":{"objectClass":"MindNode","ID":"QPE63","lineColorHex":"#B3EE3A","children":{"0":{"objectClass":"MindNode","ID":"LOM47","lineColorHex":"#B3EE3A","children":{"0":{"objectClass":"MindNode","ID":"9422F","lineColorHex":"#B3EE3A","text":"#1275. 找出井字棋的获胜者"},"1":{"objectClass":"MindNode","ID":"K555L","lineColorHex":"#B3EE3A","text":"1266. 访问所有点的最小时间"},"objectClass":"NSArray"},"text":"字数过多放弃"},"1":{"objectClass":"MindNode","ID":"FVIV2","lineColorHex":"#B3EE3A","children":{"0":{"objectClass":"MindNode","ID":"43R43","lineColorHex":"#B3EE3A","text":"#1426 数元素"},"objectClass":"NSArray"},"text":"需要开会员"},"objectClass":"NSArray"},"text":"简单"},"1":{"objectClass":"MindNode","ID":"8ML5B","lineColorHex":"#B3EE3A","text":"一般"},"2":{"objectClass":"MindNode","ID":"7FC33","lineColorHex":"#B3EE3A","text":"困难"},"objectClass":"NSArray"},"text":"未尝试"},"1":{"objectClass":"MindNode","ID":"50Q33","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"M54G8","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"MLJG4","lineColorHex":"#836FFF","children":{"0":{"objectClass":"MindNode","ID":"QG664","lineColorHex":"#836FFF","text":"描述","remark":"给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。\n\n水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。\n\n反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n\n示例 1:\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n示例 2:\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n"},"1":{"objectClass":"MindNode","ID":"453SL","lineColorHex":"#836FFF","text":"题解","remark":" /**\n     * a   b   a⊕b\n     * 1   0    1\n     * 1   1    0\n     * 0   0    0\n     * 0   1    1\n     *\n     * 异或：两个输入相同时为0，不同则为1\n     * 和1异或表示取反，和0异或 值与本身相同\n     * @param A\n     * @return\n     */\n    public static int[][] flipAndInvertImage(int[][] A) {\n        int C = A[0].length;\n        for (int[] row : A)\n            // for (int i = 0; i < (C + 1) / 2; ++i)\n            // 这句话对于偶数数组遍历一半元素，对于奇数数组遍历一半 + 1元素\n            for (int i = 0; i < (C + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[C - 1 - i] ^ 1;\n                row[C - 1 - i] = tmp;\n            }\n\n        return A;\n    }"},"2":{"objectClass":"MindNode","ID":"N354M","lineColorHex":"#836FFF","text":"思想：异或的使用、数组一半的遍历","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"#832. 翻转图像"},"1":{"objectClass":"MindNode","ID":"K9S5K","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8V9BX","lineColorHex":"#DC306C","text":"描述","remark":"给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。\n\n如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。\n\n0 <= i < j < k < arr.length\n|arr[i] - arr[j]| <= a\n|arr[j] - arr[k]| <= b\n|arr[i] - arr[k]| <= c\n其中 |x| 表示 x 的绝对值。\n\n返回 好三元组的数量 。\n\n \n\n示例 1：\n\n输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\n输出：4\n解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/count-good-triplets\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"6P6Q3","lineColorHex":"#DC306C","text":"题解","remark":"方法一：枚举\n思路与算法\n\n用 O(n^3)O(n \n3\n ) 的循环依次枚举所有的 (i, j, k)(i,j,k)，这里 0 \\leq i < j < k < {\\rm arr.length}0≤i<j<k<arr.length，对于每组 (i, j, k)(i,j,k)，判断 {\\rm arr}[i]arr[i]、{\\rm arr}[j]arr[j]、{\\rm arr}[k]arr[k] 是否满足条件。\n\n最终统计出所有满足条件的三元组的数量。\n\n代码\nclass Solution {\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\n        int n = arr.length, cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if (Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) {\n                        ++cnt;\n                    }\n                }\n            }\n        }\n        return cnt;\n    }\n}\n\n复杂度分析\n\n时间复杂度：O(n^3)\n ，其中 nn 是数组 \\textit{arr}arr 的长度。\n\n空间复杂度：O(1)。\n\n优化：\nclass Solution {\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\n        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = i+1; j < arr.length; j++) {\n                if(Math.abs(arr[i] - arr[j]) > a) continue; // 条件不满足提前退出\n                for (int k = j+1; k < arr.length ; k++) {\n                    if(Math.abs(arr[j] - arr[k]) > b) continue; // 条件不满足提前退出\n                    if(Math.abs(arr[i] - arr[k]) <= c) count++; // 满足好三元组条件\n                }\n            }\n        }\n        return count;\n    }\n}\n"},"2":{"objectClass":"MindNode","ID":"EB1WA","lineColorHex":"#DC306C","text":"思想：三重循环的优化","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1534. 统计好三元组"},"2":{"objectClass":"MindNode","ID":"0QTHI","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"7SB7U","lineColorHex":"#FFC700","text":"描述","remark":"给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。\n\n序号代表了一个元素有多大。序号编号的规则如下：\n\n序号从 1 开始编号。\n一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。\n每个数字的序号都应该尽可能地小。\n \n\n示例 1：\n\n输入：arr = [40,10,20,30]\n输出：[4,1,2,3]\n解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rank-transform-of-an-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"C2375","lineColorHex":"#FFC700","text":"题解","remark":"class Solution {\n    public int[] arrayRankTransform(int[] arr) {\n          int[] clone = arr.clone(); // clone克隆，生成一个复本\n        Map<Integer,Integer> map = new HashMap<>();\n        Arrays.sort(clone);\n        int k =1;\n        for (int i = 0; i < arr.length; i++) {\n            if(!map.keySet().contains(clone[i])){\n                map.put(clone[i],k);\n                k++;\n            }\n        }\n        for(int i=0;i<clone.length;i++){\n            arr[i] = map.get(arr[i]); // get(a[i]); key=a[i]时对应的value；\n        }\n        return arr;\n    }\n}"},"2":{"objectClass":"MindNode","ID":"4HV8B","lineColorHex":"#FFC700","text":"思想：int数组的深拷贝","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1331. 数组序号转换"},"3":{"objectClass":"MindNode","ID":"6O177","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"J6QG2","lineColorHex":"#DC306C","text":"题解","remark":"class Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n\n        // Repeat the transform k times.\n        for (;k > 0; k--) {\n\n            int previous = grid[grid.length - 1][grid[0].length - 1];\n            for (int row = 0; row < grid.length; row++) {\n                for (int col = 0; col < grid[0].length; col++) {\n                    int temp = grid[row][col];\n                    grid[row][col] = previous;\n                    previous = temp;\n                }\n            }\n        }\n\n        // Copy the grid into a list for returning.\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] row : grid) {\n            List<Integer> listRow = new ArrayList<>();\n            result.add(listRow);\n            for (int v : row) listRow.add(v);\n        }\n\n        return result;\n    }\n}"},"1":{"objectClass":"MindNode","ID":"VYCH1","lineColorHex":"#DC306C","text":"思想：模拟迁移、取摸运算","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1260. 二维网格迁移","remark":"给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。\n\n每次「迁移」操作将会引发下述活动：\n\n位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。\n位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。\n位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。\n请你返回 k 次迁移操作后最终得到的 二维网格。\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shift-2d-grid\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"4":{"objectClass":"MindNode","ID":"EP5D4","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"3ML1X","lineColorHex":"#FFC700","text":"描述","remark":"在一个给定的数组nums中，总是存在一个最大元素 。\n\n查找数组中的最大元素是否至少是数组中每个其他数字的两倍。\n\n如果是，则返回最大元素的索引，否则返回-1。\n\n示例 1:\n\n输入: nums = [3, 6, 1, 0]\n输出: 1\n解释: 6是最大的整数, 对于数组中的其他整数,\n6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"OJK3G","lineColorHex":"#FFC700","text":"题解","remark":"class Solution {\n    public int dominantIndex(int[] nums) {\n       // hashmap 保存\n       // key 最大值 ，value index\n    //    int[] copyArr = nums.clone();\n    //    Arrays.sort(copyArr);\n    //    int max = copyArr[copyArr.length-1];\n    //    int index = -1;\n    //    for(int i = 0; i < nums.length;i++){\n    //        if(nums[i] != max && nums[i]*2>max){\n    //            return -1;\n    //        }\n    //        if(nums[i] == max){\n    //            index = i;\n    //        }\n    //    }\n    //    return index;\n\n      int maxIndex = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] > nums[maxIndex])\n                maxIndex = i;\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            if (maxIndex != i && nums[maxIndex] < 2 * nums[i])\n                return -1;\n        }\n        return maxIndex;\n    }\n}"},"2":{"objectClass":"MindNode","ID":"8X0HH","lineColorHex":"#FFC700","text":"思想：找到最大位置的index，没有必要复制一个新数组出来","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"747. 至少是其他数字两倍的最大数"},"5":{"objectClass":"MindNode","ID":"U807N","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"38E4A","lineColorHex":"#26BBFF","text":"描述","remark":"斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/fibonacci-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"4XA4Z","lineColorHex":"#26BBFF","text":"题解","remark":"class Solution {\n    // public int fib(int N) {\n    //  int[] dp = new int[N+2];\n    //  dp[0] = 0;\n    //  dp[1] = 1;\n    //  for(int i = 0; i <= N;i++){\n    //      if(i>1){\n    //         dp[i] = dp[i-1] + dp[i-2];\n    //      }   \n    //  }\n    //  return dp[N];\n    // }\n\n    public int fib(int N) {\n     int pre = 0;\n     int next = 1;\n     if(N == 0 || N == 1){return N;}\n     for(int i = 2; i <= N;i++){\n         int tmp  = next;\n         next = next + pre;\n         pre = tmp;\n     }\n     return next;\n    }\n}"},"2":{"objectClass":"MindNode","ID":"6LTP3","lineColorHex":"#26BBFF","text":"思想：递归太费时间；转变为动态规划；动态规划可以优化空间复杂度。","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"509. 斐波那契数"},"6":{"objectClass":"MindNode","ID":"2321G","lineColorHex":"#A4D3EE","children":{"0":{"objectClass":"MindNode","ID":"F192S","lineColorHex":"#A4D3EE","text":"描述","remark":"给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。\n\n请你找到这个数组里第 k 个缺失的正整数。\n\n \n\n示例 1：\n\n输入：arr = [2,3,4,7,11], k = 5\n输出：9\n解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/kth-missing-positive-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"1VS70","lineColorHex":"#A4D3EE","text":"题解","remark":"public int findKthPositive(int[] arr, int k) {\n        int missCount = 0, lastMiss = -1, current = 1, ptr = 0; \n        for (missCount = 0; missCount < k; ++current) {\n            if (current == arr[ptr]) {\n                ptr = (ptr + 1 < arr.length) ? ptr + 1 : ptr;\n            } else {\n                ++missCount;\n                lastMiss = current;\n            }\n        }\n        return lastMiss;\n    }"},"objectClass":"NSArray"},"text":"1539. 第 k 个缺失的正整数"},"7":{"objectClass":"MindNode","ID":"NG202","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6EZV8","lineColorHex":"#DC306C","text":"描述","remark":"在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。\n\n请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"OV1H2","lineColorHex":"#DC306C","text":"题解","remark":"\n\npublic class Solution {\n    public static boolean checkStraightLine(int[][] coordinates) {\n        for (int i = 0; i+2 < coordinates.length; i++) {\n            if (!isInSameLine(coordinates[i], coordinates[i + 1], coordinates[i + 2])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isInSameLine(int[] coordinate1, int[] coordinate2, int[] coordinate3) {\n\n        return (coordinate2[1] - coordinate1[1]) * (coordinate3[0] - coordinate2[0]) == (coordinate3[1] - coordinate2[1]) * (coordinate2[0] - coordinate1[0]);\n    }\n}\n"},"2":{"objectClass":"MindNode","ID":"0Z9I2","lineColorHex":"#DC306C","text":"思想：如果用tan来判断，垂直会出错。因此点在直线上充要条件是：（y2-y1)*(x3-x2) == (y3-y2)*(x2-x1)","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1232. 缀点成线"},"8":{"objectClass":"MindNode","ID":"6ULRM","lineColorHex":"#836FFF","children":{"0":{"objectClass":"MindNode","ID":"E7KG5","lineColorHex":"#836FFF","text":"描述","remark":"给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。\n\n对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。\n\n你可以返回任何满足上述条件的数组作为答案。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"52O2S","lineColorHex":"#836FFF","text":"题解","remark":"方法一： 两次遍历\n思路和算法\n遍历一遍数组把所有的偶数放进 ans[0]，ans[2]，ans[4]，依次类推。\n再遍历一遍数组把所有的奇数依次放进 ans[1]，ans[3]，ans[5]，依次类推。\nclass Solution {\n    public int[] sortArrayByParityII(int[] A) {\n        int N = A.length;\n        int[] ans = new int[N];\n\n        int t = 0;\n        for (int x: A) if (x % 2 == 0) {\n            ans[t] = x;\n            t += 2;\n        }\n\n        t = 1;\n        for (int x: A) if (x % 2 == 1) {\n            ans[t] = x;\n            t += 2;\n        }\n\n        return ans;\n    }\n}\n方法二：循环\n public static int[] sortArrayByParityII(int[] A) {\n        for(int i = 0;i<A.length;i++){\n            // 奇数位置上为偶数，找到后面的奇数并交换\n            if((i%2 == 1) && (A[i]%2 == 0)){\n                int j = i + 1;\n                while(j < A.length){\n                    if(A[j]%2 != 0){\n                        // 交换位置\n                        int tmp = A[i];\n                        A[i] = A[j];\n                        A[j] = tmp;\n                        break;\n                    }\n                    j++;\n                }\n            }\n            // 偶数位置上为奇数，找到后面的偶数并交换\n            if((i%2 == 0)&&(A[i]%2 != 0)){\n                int j = i + 1;\n                while(j < A.length){\n                    if(A[j]%2 == 0){\n                        // 交换位置\n                        int tmp = A[i];\n                        A[i] = A[j];\n                        A[j] = tmp;\n                        break;\n                    }\n                    j++;\n                }\n            }\n        }\n        return A;\n    }"},"objectClass":"NSArray"},"text":"922. 按奇偶排序数组 II"},"9":{"objectClass":"MindNode","ID":"6P1T4","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"WP7PR","lineColorHex":"#37C45A","text":"描述","remark":"给你一个以行程长度编码压缩的整数列表 nums 。\n\n考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。\n\n请你返回解压后的列表。\n\n输入：nums = [1,2,3,4]\n输出：[2,4,4,4]\n解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。\n"},"1":{"objectClass":"MindNode","ID":"6SP3N","lineColorHex":"#37C45A","text":"题解","remark":"public int[] decompressRLElist(int[] nums) {\n        int len = 0,index = 0;\n        for(int i = 0;i<=nums.length-2;i+=2){\n            len += nums[i];\n        }\n        int[] ans = new int[len];\n        for(int i = 0;i<=nums.length-2;i+=2){\n            int freq = nums[i];\n            int val = nums[i+1];\n            int j = 0;\n            while(j < freq){\n              ans[index++] = val;\n                j++;\n            }\n        }\n        return ans;\n    }"},"2":{"objectClass":"MindNode","ID":"52522","lineColorHex":"#37C45A","text":"思想：压缩编码，缩短字符长度","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1313. 解压缩编码列表"},"10":{"objectClass":"MindNode","ID":"YK2H9","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7R124","lineColorHex":"#DC306C","text":"描述","remark":"给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。\n\n我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-pivot-index\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n"},"1":{"objectClass":"MindNode","ID":"R3GJ8","lineColorHex":"#DC306C","text":"题解","remark":"class Solution {\n    public int pivotIndex(int[] nums) {\n        int sum = 0, leftsum = 0;\n        for (int x: nums) sum += x;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == sum - leftsum - nums[i]) return i;\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}\n"},"2":{"objectClass":"MindNode","ID":"36O8W","lineColorHex":"#DC306C","text":"思想：S 是数组的和，当索引 i 是中心索引时，位于 i 左边数组元素的和 leftsum 满足 S - nums[i] - leftsum。","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"724. 寻找数组的中心索引"},"11":{"objectClass":"MindNode","ID":"M6755","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7933V","lineColorHex":"#DC306C","text":"描述","remark":"给你一个由一些多米诺骨牌组成的列表 dominoes。\n\n如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。\n\n形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。\n\n在 0 <= i < j < dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。\n\n \n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"},"1":{"objectClass":"MindNode","ID":"O151U","lineColorHex":"#DC306C","text":"题解","remark":"class Solution {\n    public static int numEquivDominoPairs(int[][] dominoes) {\n        HashMap<String, Integer> map = new HashMap<>();\n        int ans = 0;\n        int row = dominoes.length;\n        for (int i = 0; i < row; i++) {\n            int[] dominoe = dominoes[i];\n            int first = dominoe[0];\n            int second = dominoe[1];\n            if (second < first) {\n                int tmp = first;\n                first = second;\n                second = tmp;\n            }\n            String key = first + \"\" + second;\n            if (map.containsKey(key)) {\n                int value = map.get(key) + 1;\n                map.put(key, value);\n            } else {\n                map.put(key, 1);\n            }\n        }\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n                // 注意这里为什么是这样计算\n                ans+=entry.getValue()*(entry.getValue()-1)/2;\n        }\n\n        return ans;\n    }\n}"},"2":{"objectClass":"MindNode","ID":"7HN0L","lineColorHex":"#DC306C","text":"思想：1.对于a,b和b，a转换成“ab”的形式当作key；\n2.排列组合。n选2有（n*（n-1)/2）种选法。第一次选有n种，第二次选有n-1种，因为第一次可能选到第二次的结果，两种视为同一结果，因为无序，所以除以2.","style2":{"objectClass":"NSDictionary","color":"#FF0000"}},"objectClass":"NSArray"},"text":"1128. 等价多米诺骨牌对的数量"},"objectClass":"NSArray"},"text":"简单"},"1":{"objectClass":"MindNode","ID":"AB83M","lineColorHex":"#DC306C","text":"一般"},"2":{"objectClass":"MindNode","ID":"EIL96","lineColorHex":"#DC306C","text":"困难"},"objectClass":"NSArray"},"text":"已通过"},"objectClass":"NSArray"},"text":"数组"},"objectClass":"NSArray"},"text":"算法"},"ID":"R70T7"}